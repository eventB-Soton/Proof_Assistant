/*
 * generated by Xtext 2.16.0
 */
package ac.soton.xeventb.xproofassistant.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class XProofAssistantGrammarAccess extends AbstractGrammarElementFinder {
	
	public class XProofAssistantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xproofassistant.XProofAssistant.XProofAssistant");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cProofAssistantKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameEStringParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cSupportsKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cComponentAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final CrossReference cComponentEventBNamedCommentedComponentElementCrossReference_3_0 = (CrossReference)cComponentAssignment_3.eContents().get(0);
		private final RuleCall cComponentEventBNamedCommentedComponentElementEStringParserRuleCall_3_0_1 = (RuleCall)cComponentEventBNamedCommentedComponentElementCrossReference_3_0.eContents().get(1);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cHintsKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cHintsAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cHintsXHintParserRuleCall_4_1_0 = (RuleCall)cHintsAssignment_4_1.eContents().get(0);
		private final Keyword cEndKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//XProofAssistant ProofAssistant:
		//	'ProofAssistant' name=EString
		//	'supports' component=[core::EventBNamedCommentedComponentElement|EString] ('hints' hints+=XHint+)*
		//	'end';
		@Override public ParserRule getRule() { return rule; }
		
		//'ProofAssistant' name=EString 'supports' component=[core::EventBNamedCommentedComponentElement|EString] ('hints'
		//hints+=XHint+)* 'end'
		public Group getGroup() { return cGroup; }
		
		//'ProofAssistant'
		public Keyword getProofAssistantKeyword_0() { return cProofAssistantKeyword_0; }
		
		//name=EString
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//EString
		public RuleCall getNameEStringParserRuleCall_1_0() { return cNameEStringParserRuleCall_1_0; }
		
		//'supports'
		public Keyword getSupportsKeyword_2() { return cSupportsKeyword_2; }
		
		//component=[core::EventBNamedCommentedComponentElement|EString]
		public Assignment getComponentAssignment_3() { return cComponentAssignment_3; }
		
		//[core::EventBNamedCommentedComponentElement|EString]
		public CrossReference getComponentEventBNamedCommentedComponentElementCrossReference_3_0() { return cComponentEventBNamedCommentedComponentElementCrossReference_3_0; }
		
		//EString
		public RuleCall getComponentEventBNamedCommentedComponentElementEStringParserRuleCall_3_0_1() { return cComponentEventBNamedCommentedComponentElementEStringParserRuleCall_3_0_1; }
		
		//('hints' hints+=XHint+)*
		public Group getGroup_4() { return cGroup_4; }
		
		//'hints'
		public Keyword getHintsKeyword_4_0() { return cHintsKeyword_4_0; }
		
		//hints+=XHint+
		public Assignment getHintsAssignment_4_1() { return cHintsAssignment_4_1; }
		
		//XHint
		public RuleCall getHintsXHintParserRuleCall_4_1_0() { return cHintsXHintParserRuleCall_4_1_0; }
		
		//'end'
		public Keyword getEndKeyword_5() { return cEndKeyword_5; }
	}
	public class XHintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xproofassistant.XProofAssistant.XHint");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cXSelectionHintParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cXCasesHintParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//XHint Hint:
		//	XSelectionHint | XCasesHint;
		@Override public ParserRule getRule() { return rule; }
		
		//XSelectionHint | XCasesHint
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//XSelectionHint
		public RuleCall getXSelectionHintParserRuleCall_0() { return cXSelectionHintParserRuleCall_0; }
		
		//XCasesHint
		public RuleCall getXCasesHintParserRuleCall_1() { return cXCasesHintParserRuleCall_1; }
	}
	public class EStringElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xproofassistant.XProofAssistant.EString");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//EString:
		//	STRING | ID;
		@Override public ParserRule getRule() { return rule; }
		
		//STRING | ID
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//STRING
		public RuleCall getSTRINGTerminalRuleCall_0() { return cSTRINGTerminalRuleCall_0; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_1() { return cIDTerminalRuleCall_1; }
	}
	public class XSelectionHintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xproofassistant.XProofAssistant.XSelectionHint");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cForKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cElementAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cElementEventBElementCrossReference_1_0 = (CrossReference)cElementAssignment_1.eContents().get(0);
		private final RuleCall cElementEventBElementEStringParserRuleCall_1_0_1 = (RuleCall)cElementEventBElementCrossReference_1_0.eContents().get(1);
		private final Keyword cSelectsKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cSelectionsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final CrossReference cSelectionsEventBElementCrossReference_3_0 = (CrossReference)cSelectionsAssignment_3.eContents().get(0);
		private final RuleCall cSelectionsEventBElementEStringParserRuleCall_3_0_1 = (RuleCall)cSelectionsEventBElementCrossReference_3_0.eContents().get(1);
		
		//XSelectionHint SelectionHint:
		//	'for' element=[core::EventBElement|EString]
		//	'selects' selections+=[core::EventBElement|EString]+;
		@Override public ParserRule getRule() { return rule; }
		
		//'for' element=[core::EventBElement|EString] 'selects' selections+=[core::EventBElement|EString]+
		public Group getGroup() { return cGroup; }
		
		//'for'
		public Keyword getForKeyword_0() { return cForKeyword_0; }
		
		//element=[core::EventBElement|EString]
		public Assignment getElementAssignment_1() { return cElementAssignment_1; }
		
		//[core::EventBElement|EString]
		public CrossReference getElementEventBElementCrossReference_1_0() { return cElementEventBElementCrossReference_1_0; }
		
		//EString
		public RuleCall getElementEventBElementEStringParserRuleCall_1_0_1() { return cElementEventBElementEStringParserRuleCall_1_0_1; }
		
		//'selects'
		public Keyword getSelectsKeyword_2() { return cSelectsKeyword_2; }
		
		//selections+=[core::EventBElement|EString]+
		public Assignment getSelectionsAssignment_3() { return cSelectionsAssignment_3; }
		
		//[core::EventBElement|EString]
		public CrossReference getSelectionsEventBElementCrossReference_3_0() { return cSelectionsEventBElementCrossReference_3_0; }
		
		//EString
		public RuleCall getSelectionsEventBElementEStringParserRuleCall_3_0_1() { return cSelectionsEventBElementEStringParserRuleCall_3_0_1; }
	}
	public class XCasesHintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xproofassistant.XProofAssistant.XCasesHint");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cForKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cElementAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cElementEventBElementCrossReference_1_0 = (CrossReference)cElementAssignment_1.eContents().get(0);
		private final RuleCall cElementEventBElementEStringParserRuleCall_1_0_1 = (RuleCall)cElementEventBElementCrossReference_1_0.eContents().get(1);
		private final Keyword cCasesKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cCasesAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cCasesXCaseParserRuleCall_3_0 = (RuleCall)cCasesAssignment_3.eContents().get(0);
		
		//XCasesHint CasesHint:
		//	'for' element=[core::EventBElement|EString]
		//	'cases' cases+=XCase+;
		@Override public ParserRule getRule() { return rule; }
		
		//'for' element=[core::EventBElement|EString] 'cases' cases+=XCase+
		public Group getGroup() { return cGroup; }
		
		//'for'
		public Keyword getForKeyword_0() { return cForKeyword_0; }
		
		//element=[core::EventBElement|EString]
		public Assignment getElementAssignment_1() { return cElementAssignment_1; }
		
		//[core::EventBElement|EString]
		public CrossReference getElementEventBElementCrossReference_1_0() { return cElementEventBElementCrossReference_1_0; }
		
		//EString
		public RuleCall getElementEventBElementEStringParserRuleCall_1_0_1() { return cElementEventBElementEStringParserRuleCall_1_0_1; }
		
		//'cases'
		public Keyword getCasesKeyword_2() { return cCasesKeyword_2; }
		
		//cases+=XCase+
		public Assignment getCasesAssignment_3() { return cCasesAssignment_3; }
		
		//XCase
		public RuleCall getCasesXCaseParserRuleCall_3_0() { return cCasesXCaseParserRuleCall_3_0; }
	}
	public class XCaseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xproofassistant.XProofAssistant.XCase");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameXLABELTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Assignment cPredicateAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPredicateXFormulaParserRuleCall_1_0 = (RuleCall)cPredicateAssignment_1.eContents().get(0);
		
		//XCase Case:
		//	name=XLABEL predicate=XFormula;
		@Override public ParserRule getRule() { return rule; }
		
		//name=XLABEL predicate=XFormula
		public Group getGroup() { return cGroup; }
		
		//name=XLABEL
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//XLABEL
		public RuleCall getNameXLABELTerminalRuleCall_0_0() { return cNameXLABELTerminalRuleCall_0_0; }
		
		//predicate=XFormula
		public Assignment getPredicateAssignment_1() { return cPredicateAssignment_1; }
		
		//XFormula
		public RuleCall getPredicateXFormulaParserRuleCall_1_0() { return cPredicateXFormulaParserRuleCall_1_0; }
	}
	public class XFormulaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xproofassistant.XProofAssistant.XFormula");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cEVENTB_IDENTIFIER_KEYWORDParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cEVENTB_PREDICATE_SYMBOLSParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cEVENTB_EXPRESSION_SYMBOLSParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cIDTerminalRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cINTTerminalRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//XFormula:
		//	(EVENTB_IDENTIFIER_KEYWORD | EVENTB_PREDICATE_SYMBOLS | EVENTB_EXPRESSION_SYMBOLS | ID | INT)+;
		@Override public ParserRule getRule() { return rule; }
		
		//(EVENTB_IDENTIFIER_KEYWORD | EVENTB_PREDICATE_SYMBOLS | EVENTB_EXPRESSION_SYMBOLS | ID | INT)+
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//EVENTB_IDENTIFIER_KEYWORD
		public RuleCall getEVENTB_IDENTIFIER_KEYWORDParserRuleCall_0() { return cEVENTB_IDENTIFIER_KEYWORDParserRuleCall_0; }
		
		//EVENTB_PREDICATE_SYMBOLS
		public RuleCall getEVENTB_PREDICATE_SYMBOLSParserRuleCall_1() { return cEVENTB_PREDICATE_SYMBOLSParserRuleCall_1; }
		
		//EVENTB_EXPRESSION_SYMBOLS
		public RuleCall getEVENTB_EXPRESSION_SYMBOLSParserRuleCall_2() { return cEVENTB_EXPRESSION_SYMBOLSParserRuleCall_2; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_3() { return cIDTerminalRuleCall_3; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_4() { return cINTTerminalRuleCall_4; }
	}
	public class EVENTB_IDENTIFIER_KEYWORDElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xproofassistant.XProofAssistant.EVENTB_IDENTIFIER_KEYWORD");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cBOOLKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cFALSEKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cTRUEKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cBoolKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cCardKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cDomKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cFiniteKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cIdKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cInterKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cMaxKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cMinKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final Keyword cModKeyword_11 = (Keyword)cAlternatives.eContents().get(11);
		private final Keyword cPredKeyword_12 = (Keyword)cAlternatives.eContents().get(12);
		private final Keyword cPrj1Keyword_13 = (Keyword)cAlternatives.eContents().get(13);
		private final Keyword cPrj2Keyword_14 = (Keyword)cAlternatives.eContents().get(14);
		private final Keyword cRanKeyword_15 = (Keyword)cAlternatives.eContents().get(15);
		private final Keyword cSuccKeyword_16 = (Keyword)cAlternatives.eContents().get(16);
		private final Keyword cUnionKeyword_17 = (Keyword)cAlternatives.eContents().get(17);
		private final Keyword cDoubleStruckCapitalNDigitOneKeyword_18 = (Keyword)cAlternatives.eContents().get(18);
		private final Keyword cDoubleStruckCapitalNKeyword_19 = (Keyword)cAlternatives.eContents().get(19);
		private final Keyword cDoubleStruckCapitalPDigitOneKeyword_20 = (Keyword)cAlternatives.eContents().get(20);
		private final Keyword cDoubleStruckCapitalPKeyword_21 = (Keyword)cAlternatives.eContents().get(21);
		private final Keyword cDoubleStruckCapitalZKeyword_22 = (Keyword)cAlternatives.eContents().get(22);
		
		//EVENTB_IDENTIFIER_KEYWORD:
		//	'BOOL' |
		//	'FALSE' |
		//	'TRUE' |
		//	'bool' |
		//	'card' |
		//	'dom' |
		//	'finite' |
		//	'id' |
		//	'inter' |
		//	'max' |
		//	'min' |
		//	'mod' |
		//	'pred' |
		//	'prj1' |
		//	'prj2' |
		//	'ran' |
		//	'succ' |
		//	'union' |
		//	'ℕ1' |
		//	'ℕ' |
		//	'ℙ1' |
		//	'ℙ' |
		//	'ℤ';
		@Override public ParserRule getRule() { return rule; }
		
		//'BOOL' | 'FALSE' | 'TRUE' | 'bool' | 'card' | 'dom' | 'finite' | 'id' | 'inter' | 'max' | 'min' | 'mod' | 'pred' |
		//'prj1' | 'prj2' | 'ran' | 'succ' | 'union' | 'ℕ1' | 'ℕ' | 'ℙ1' | 'ℙ' | 'ℤ'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'BOOL'
		public Keyword getBOOLKeyword_0() { return cBOOLKeyword_0; }
		
		//'FALSE'
		public Keyword getFALSEKeyword_1() { return cFALSEKeyword_1; }
		
		//'TRUE'
		public Keyword getTRUEKeyword_2() { return cTRUEKeyword_2; }
		
		//'bool'
		public Keyword getBoolKeyword_3() { return cBoolKeyword_3; }
		
		//'card'
		public Keyword getCardKeyword_4() { return cCardKeyword_4; }
		
		//'dom'
		public Keyword getDomKeyword_5() { return cDomKeyword_5; }
		
		//'finite'
		public Keyword getFiniteKeyword_6() { return cFiniteKeyword_6; }
		
		//'id'
		public Keyword getIdKeyword_7() { return cIdKeyword_7; }
		
		//'inter'
		public Keyword getInterKeyword_8() { return cInterKeyword_8; }
		
		//'max'
		public Keyword getMaxKeyword_9() { return cMaxKeyword_9; }
		
		//'min'
		public Keyword getMinKeyword_10() { return cMinKeyword_10; }
		
		//'mod'
		public Keyword getModKeyword_11() { return cModKeyword_11; }
		
		//'pred'
		public Keyword getPredKeyword_12() { return cPredKeyword_12; }
		
		//'prj1'
		public Keyword getPrj1Keyword_13() { return cPrj1Keyword_13; }
		
		//'prj2'
		public Keyword getPrj2Keyword_14() { return cPrj2Keyword_14; }
		
		//'ran'
		public Keyword getRanKeyword_15() { return cRanKeyword_15; }
		
		//'succ'
		public Keyword getSuccKeyword_16() { return cSuccKeyword_16; }
		
		//'union'
		public Keyword getUnionKeyword_17() { return cUnionKeyword_17; }
		
		//'ℕ1'
		public Keyword getDoubleStruckCapitalNDigitOneKeyword_18() { return cDoubleStruckCapitalNDigitOneKeyword_18; }
		
		//'ℕ'
		public Keyword getDoubleStruckCapitalNKeyword_19() { return cDoubleStruckCapitalNKeyword_19; }
		
		//'ℙ1'
		public Keyword getDoubleStruckCapitalPDigitOneKeyword_20() { return cDoubleStruckCapitalPDigitOneKeyword_20; }
		
		//'ℙ'
		public Keyword getDoubleStruckCapitalPKeyword_21() { return cDoubleStruckCapitalPKeyword_21; }
		
		//'ℤ'
		public Keyword getDoubleStruckCapitalZKeyword_22() { return cDoubleStruckCapitalZKeyword_22; }
	}
	public class EVENTB_PREDICATE_SYMBOLSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xproofassistant.XProofAssistant.EVENTB_PREDICATE_SYMBOLS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cLeftRightDoubleArrowKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cRightwardsDoubleArrowKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cLogicalAndKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cAmpersandKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cLogicalOrKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cNotSignKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cDownTackKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cUpTackKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cForAllKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final Keyword cExclamationMarkKeyword_11 = (Keyword)cAlternatives.eContents().get(11);
		private final Keyword cThereExistsKeyword_12 = (Keyword)cAlternatives.eContents().get(12);
		private final Keyword cNumberSignKeyword_13 = (Keyword)cAlternatives.eContents().get(13);
		private final Keyword cCommaKeyword_14 = (Keyword)cAlternatives.eContents().get(14);
		private final Keyword cMiddleDotKeyword_15 = (Keyword)cAlternatives.eContents().get(15);
		private final Keyword cFullStopKeyword_16 = (Keyword)cAlternatives.eContents().get(16);
		private final Keyword cEqualsSignKeyword_17 = (Keyword)cAlternatives.eContents().get(17);
		private final Keyword cNotEqualToKeyword_18 = (Keyword)cAlternatives.eContents().get(18);
		private final Keyword cLessThanOrEqualToKeyword_19 = (Keyword)cAlternatives.eContents().get(19);
		private final Keyword cLessThanSignKeyword_20 = (Keyword)cAlternatives.eContents().get(20);
		private final Keyword cGreaterThanOrEqualToKeyword_21 = (Keyword)cAlternatives.eContents().get(21);
		private final Keyword cGreaterThanSignKeyword_22 = (Keyword)cAlternatives.eContents().get(22);
		private final Keyword cElementOfKeyword_23 = (Keyword)cAlternatives.eContents().get(23);
		private final Keyword cColonKeyword_24 = (Keyword)cAlternatives.eContents().get(24);
		private final Keyword cNotAnElementOfKeyword_25 = (Keyword)cAlternatives.eContents().get(25);
		private final Keyword cSubsetOfKeyword_26 = (Keyword)cAlternatives.eContents().get(26);
		private final Keyword cNotASubsetOfKeyword_27 = (Keyword)cAlternatives.eContents().get(27);
		private final Keyword cSubsetOfOrEqualToKeyword_28 = (Keyword)cAlternatives.eContents().get(28);
		private final Keyword cNeitherASubsetOfNorEqualToKeyword_29 = (Keyword)cAlternatives.eContents().get(29);
		private final Keyword cPartitionKeyword_30 = (Keyword)cAlternatives.eContents().get(30);
		
		//EVENTB_PREDICATE_SYMBOLS:
		//	'(' | // Predicate calculus symbols
		//	')' |
		//	'⇔' |
		//	'⇒' |
		//	'∧' | '&' |
		//	'∨' |
		//	'¬' |
		//	'⊤' |
		//	'⊥' |
		//	'∀' | '!' |
		//	'∃' | '#' |
		//	',' |
		//	'·' | '.' |
		//	'=' | // Build predicates from expressions
		//	'≠' |
		//	'≤' |
		//	'<' |
		//	'≥' |
		//	'>' |
		//	'∈' | ':' | // Include this for Rodin keyboard
		//	'∉' |
		//	'⊂' |
		//	'⊄' |
		//	'⊆' |
		//	'⊈' |
		//	'partition' // This is missing from the Rodin D7 deliverable
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'(' | // Predicate calculus symbols
		//')' | '⇔' | '⇒' | '∧' | '&' | '∨' | '¬' | '⊤' | '⊥' | '∀' | '!' | '∃' | '#' | ',' | '·' | '.' | '=' | // Build predicates from expressions
		//'≠' | '≤' | '<' | '≥' | '>' | '∈' | ':' | // Include this for Rodin keyboard
		//'∉' | '⊂' | '⊄' | '⊆' | '⊈' | 'partition'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//// Predicate calculus symbols
		//')'
		public Keyword getRightParenthesisKeyword_1() { return cRightParenthesisKeyword_1; }
		
		//'⇔'
		public Keyword getLeftRightDoubleArrowKeyword_2() { return cLeftRightDoubleArrowKeyword_2; }
		
		//'⇒'
		public Keyword getRightwardsDoubleArrowKeyword_3() { return cRightwardsDoubleArrowKeyword_3; }
		
		//'∧'
		public Keyword getLogicalAndKeyword_4() { return cLogicalAndKeyword_4; }
		
		//'&'
		public Keyword getAmpersandKeyword_5() { return cAmpersandKeyword_5; }
		
		//'∨'
		public Keyword getLogicalOrKeyword_6() { return cLogicalOrKeyword_6; }
		
		//'¬'
		public Keyword getNotSignKeyword_7() { return cNotSignKeyword_7; }
		
		//'⊤'
		public Keyword getDownTackKeyword_8() { return cDownTackKeyword_8; }
		
		//'⊥'
		public Keyword getUpTackKeyword_9() { return cUpTackKeyword_9; }
		
		//'∀'
		public Keyword getForAllKeyword_10() { return cForAllKeyword_10; }
		
		//'!'
		public Keyword getExclamationMarkKeyword_11() { return cExclamationMarkKeyword_11; }
		
		//'∃'
		public Keyword getThereExistsKeyword_12() { return cThereExistsKeyword_12; }
		
		//'#'
		public Keyword getNumberSignKeyword_13() { return cNumberSignKeyword_13; }
		
		//','
		public Keyword getCommaKeyword_14() { return cCommaKeyword_14; }
		
		//'·'
		public Keyword getMiddleDotKeyword_15() { return cMiddleDotKeyword_15; }
		
		//'.'
		public Keyword getFullStopKeyword_16() { return cFullStopKeyword_16; }
		
		//'='
		public Keyword getEqualsSignKeyword_17() { return cEqualsSignKeyword_17; }
		
		//// Build predicates from expressions
		//'≠'
		public Keyword getNotEqualToKeyword_18() { return cNotEqualToKeyword_18; }
		
		//'≤'
		public Keyword getLessThanOrEqualToKeyword_19() { return cLessThanOrEqualToKeyword_19; }
		
		//'<'
		public Keyword getLessThanSignKeyword_20() { return cLessThanSignKeyword_20; }
		
		//'≥'
		public Keyword getGreaterThanOrEqualToKeyword_21() { return cGreaterThanOrEqualToKeyword_21; }
		
		//'>'
		public Keyword getGreaterThanSignKeyword_22() { return cGreaterThanSignKeyword_22; }
		
		//'∈'
		public Keyword getElementOfKeyword_23() { return cElementOfKeyword_23; }
		
		//':'
		public Keyword getColonKeyword_24() { return cColonKeyword_24; }
		
		//// Include this for Rodin keyboard
		//'∉'
		public Keyword getNotAnElementOfKeyword_25() { return cNotAnElementOfKeyword_25; }
		
		//'⊂'
		public Keyword getSubsetOfKeyword_26() { return cSubsetOfKeyword_26; }
		
		//'⊄'
		public Keyword getNotASubsetOfKeyword_27() { return cNotASubsetOfKeyword_27; }
		
		//'⊆'
		public Keyword getSubsetOfOrEqualToKeyword_28() { return cSubsetOfOrEqualToKeyword_28; }
		
		//'⊈'
		public Keyword getNeitherASubsetOfNorEqualToKeyword_29() { return cNeitherASubsetOfNorEqualToKeyword_29; }
		
		//'partition'
		public Keyword getPartitionKeyword_30() { return cPartitionKeyword_30; }
	}
	public class EVENTB_EXPRESSION_SYMBOLSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xproofassistant.XProofAssistant.EVENTB_EXPRESSION_SYMBOLS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cLeftRightArrowKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cPrivateUseAreaE100Keyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cPrivateUseAreaE101Keyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cPrivateUseAreaE102Keyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cRightwardsArrowWithVerticalStrokeKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cRightwardsArrowKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cRightwardsArrowWithTailWithVerticalStrokeKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cRightwardsArrowWithTailKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cRightwardsTwoHeadedArrowWithVerticalStrokeKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cRightwardsTwoHeadedArrowKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cRightwardsTwoHeadedArrowWithTailKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final Keyword cLeftCurlyBracketKeyword_11 = (Keyword)cAlternatives.eContents().get(11);
		private final Keyword cRightCurlyBracketKeyword_12 = (Keyword)cAlternatives.eContents().get(12);
		private final Keyword cRightwardsArrowFromBarKeyword_13 = (Keyword)cAlternatives.eContents().get(13);
		private final Keyword cEmptySetKeyword_14 = (Keyword)cAlternatives.eContents().get(14);
		private final Keyword cIntersectionKeyword_15 = (Keyword)cAlternatives.eContents().get(15);
		private final Keyword cUnionKeyword_16 = (Keyword)cAlternatives.eContents().get(16);
		private final Keyword cSetMinusKeyword_17 = (Keyword)cAlternatives.eContents().get(17);
		private final Keyword cMultiplicationSignKeyword_18 = (Keyword)cAlternatives.eContents().get(18);
		private final Keyword cLeftSquareBracketKeyword_19 = (Keyword)cAlternatives.eContents().get(19);
		private final Keyword cRightSquareBracketKeyword_20 = (Keyword)cAlternatives.eContents().get(20);
		private final Keyword cPrivateUseAreaE103Keyword_21 = (Keyword)cAlternatives.eContents().get(21);
		private final Keyword cRingOperatorKeyword_22 = (Keyword)cAlternatives.eContents().get(22);
		private final Keyword cSemicolonKeyword_23 = (Keyword)cAlternatives.eContents().get(23);
		private final Keyword cCircledTimesKeyword_24 = (Keyword)cAlternatives.eContents().get(24);
		private final Keyword cParallelToKeyword_25 = (Keyword)cAlternatives.eContents().get(25);
		private final Keyword cTildeOperatorKeyword_26 = (Keyword)cAlternatives.eContents().get(26);
		private final Keyword cWhiteLeftPointingTriangleKeyword_27 = (Keyword)cAlternatives.eContents().get(27);
		private final Keyword cZNotationDomainAntirestrictionKeyword_28 = (Keyword)cAlternatives.eContents().get(28);
		private final Keyword cWhiteRightPointingTriangleKeyword_29 = (Keyword)cAlternatives.eContents().get(29);
		private final Keyword cZNotationRangeAntirestrictionKeyword_30 = (Keyword)cAlternatives.eContents().get(30);
		private final Keyword cGreekSmallLetterLamdaKeyword_31 = (Keyword)cAlternatives.eContents().get(31);
		private final Group cGroup_32 = (Group)cAlternatives.eContents().get(32);
		private final Keyword cPercentSignKeyword_32_0 = (Keyword)cGroup_32.eContents().get(0);
		private final Keyword cNAryIntersectionKeyword_32_1 = (Keyword)cGroup_32.eContents().get(1);
		private final Keyword cNAryUnionKeyword_33 = (Keyword)cAlternatives.eContents().get(33);
		private final Keyword cDividesKeyword_34 = (Keyword)cAlternatives.eContents().get(34);
		private final Keyword cTwoDotLeaderKeyword_35 = (Keyword)cAlternatives.eContents().get(35);
		private final Keyword cPlusSignKeyword_36 = (Keyword)cAlternatives.eContents().get(36);
		private final Keyword cMinusSignKeyword_37 = (Keyword)cAlternatives.eContents().get(37);
		private final Keyword cHyphenMinusKeyword_38 = (Keyword)cAlternatives.eContents().get(38);
		private final Keyword cAsteriskOperatorKeyword_39 = (Keyword)cAlternatives.eContents().get(39);
		private final Keyword cAsteriskKeyword_40 = (Keyword)cAlternatives.eContents().get(40);
		private final Keyword cDivisionSignKeyword_41 = (Keyword)cAlternatives.eContents().get(41);
		private final Keyword cSolidusKeyword_42 = (Keyword)cAlternatives.eContents().get(42);
		private final Keyword cCircumflexAccentKeyword_43 = (Keyword)cAlternatives.eContents().get(43);
		private final Keyword cBackslashKeyword_44 = (Keyword)cAlternatives.eContents().get(44);
		
		//EVENTB_EXPRESSION_SYMBOLS:
		//	'↔' | // Symbols for building set of relations
		//	'' |
		//	'' |
		//	'' |
		//	'⇸' |
		//	'→' |
		//	'⤔' |
		//	'↣' |
		//	'⤀' |
		//	'↠' |
		//	'⤖' |
		//	'{' | // Symbols for manipulating sets
		//	'}' |
		//	'↦' |
		//	'∅' |
		//	'∩' |
		//	'∪' |
		//	'∖' |
		//	'×' |
		//	'[' | // Symbols for manipulating functions and relations
		//	']' |
		//	'' |
		//	'∘' |
		//	';' |
		//	'⊗' |
		//	'∥' |
		//	'∼' |
		//	'◁' |
		//	'⩤' |
		//	'▷' |
		//	'⩥' |
		//	'λ' | '%' // Symbols for quantified expressions
		//	'⋂' |
		//	'⋃' |
		//	'∣' |
		//	'‥' | // Symbols for arithmetic expressions
		//	'+' |
		//	'−' | '-' |
		//	'∗' | '*' |
		//	'÷' | '/' |
		//	'^' |
		//	'\\' // Allowed for LaTeX combos
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'↔' | // Symbols for building set of relations
		//'' | '' | '' | '⇸' | '→' | '⤔' | '↣' | '⤀' | '↠' | '⤖' | '{' | // Symbols for manipulating sets
		//'}' | '↦' | '∅' | '∩' | '∪' | '∖' | '×' | '[' | // Symbols for manipulating functions and relations
		//']' | '' | '∘' | ';' | '⊗' | '∥' | '∼' | '◁' | '⩤' | '▷' | '⩥' | 'λ' | '%' // Symbols for quantified expressions
		//'⋂' | '⋃' | '∣' | '‥' | // Symbols for arithmetic expressions
		//'+' | '−' | '-' | '∗' | '*' | '÷' | '/' | '^' | '\\'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'↔'
		public Keyword getLeftRightArrowKeyword_0() { return cLeftRightArrowKeyword_0; }
		
		//// Symbols for building set of relations
		//''
		public Keyword getPrivateUseAreaE100Keyword_1() { return cPrivateUseAreaE100Keyword_1; }
		
		//''
		public Keyword getPrivateUseAreaE101Keyword_2() { return cPrivateUseAreaE101Keyword_2; }
		
		//''
		public Keyword getPrivateUseAreaE102Keyword_3() { return cPrivateUseAreaE102Keyword_3; }
		
		//'⇸'
		public Keyword getRightwardsArrowWithVerticalStrokeKeyword_4() { return cRightwardsArrowWithVerticalStrokeKeyword_4; }
		
		//'→'
		public Keyword getRightwardsArrowKeyword_5() { return cRightwardsArrowKeyword_5; }
		
		//'⤔'
		public Keyword getRightwardsArrowWithTailWithVerticalStrokeKeyword_6() { return cRightwardsArrowWithTailWithVerticalStrokeKeyword_6; }
		
		//'↣'
		public Keyword getRightwardsArrowWithTailKeyword_7() { return cRightwardsArrowWithTailKeyword_7; }
		
		//'⤀'
		public Keyword getRightwardsTwoHeadedArrowWithVerticalStrokeKeyword_8() { return cRightwardsTwoHeadedArrowWithVerticalStrokeKeyword_8; }
		
		//'↠'
		public Keyword getRightwardsTwoHeadedArrowKeyword_9() { return cRightwardsTwoHeadedArrowKeyword_9; }
		
		//'⤖'
		public Keyword getRightwardsTwoHeadedArrowWithTailKeyword_10() { return cRightwardsTwoHeadedArrowWithTailKeyword_10; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_11() { return cLeftCurlyBracketKeyword_11; }
		
		//// Symbols for manipulating sets
		//'}'
		public Keyword getRightCurlyBracketKeyword_12() { return cRightCurlyBracketKeyword_12; }
		
		//'↦'
		public Keyword getRightwardsArrowFromBarKeyword_13() { return cRightwardsArrowFromBarKeyword_13; }
		
		//'∅'
		public Keyword getEmptySetKeyword_14() { return cEmptySetKeyword_14; }
		
		//'∩'
		public Keyword getIntersectionKeyword_15() { return cIntersectionKeyword_15; }
		
		//'∪'
		public Keyword getUnionKeyword_16() { return cUnionKeyword_16; }
		
		//'∖'
		public Keyword getSetMinusKeyword_17() { return cSetMinusKeyword_17; }
		
		//'×'
		public Keyword getMultiplicationSignKeyword_18() { return cMultiplicationSignKeyword_18; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_19() { return cLeftSquareBracketKeyword_19; }
		
		//// Symbols for manipulating functions and relations
		//']'
		public Keyword getRightSquareBracketKeyword_20() { return cRightSquareBracketKeyword_20; }
		
		//''
		public Keyword getPrivateUseAreaE103Keyword_21() { return cPrivateUseAreaE103Keyword_21; }
		
		//'∘'
		public Keyword getRingOperatorKeyword_22() { return cRingOperatorKeyword_22; }
		
		//';'
		public Keyword getSemicolonKeyword_23() { return cSemicolonKeyword_23; }
		
		//'⊗'
		public Keyword getCircledTimesKeyword_24() { return cCircledTimesKeyword_24; }
		
		//'∥'
		public Keyword getParallelToKeyword_25() { return cParallelToKeyword_25; }
		
		//'∼'
		public Keyword getTildeOperatorKeyword_26() { return cTildeOperatorKeyword_26; }
		
		//'◁'
		public Keyword getWhiteLeftPointingTriangleKeyword_27() { return cWhiteLeftPointingTriangleKeyword_27; }
		
		//'⩤'
		public Keyword getZNotationDomainAntirestrictionKeyword_28() { return cZNotationDomainAntirestrictionKeyword_28; }
		
		//'▷'
		public Keyword getWhiteRightPointingTriangleKeyword_29() { return cWhiteRightPointingTriangleKeyword_29; }
		
		//'⩥'
		public Keyword getZNotationRangeAntirestrictionKeyword_30() { return cZNotationRangeAntirestrictionKeyword_30; }
		
		//'λ'
		public Keyword getGreekSmallLetterLamdaKeyword_31() { return cGreekSmallLetterLamdaKeyword_31; }
		
		//'%' // Symbols for quantified expressions
		//'⋂'
		public Group getGroup_32() { return cGroup_32; }
		
		//'%'
		public Keyword getPercentSignKeyword_32_0() { return cPercentSignKeyword_32_0; }
		
		//// Symbols for quantified expressions
		//'⋂'
		public Keyword getNAryIntersectionKeyword_32_1() { return cNAryIntersectionKeyword_32_1; }
		
		//'⋃'
		public Keyword getNAryUnionKeyword_33() { return cNAryUnionKeyword_33; }
		
		//'∣'
		public Keyword getDividesKeyword_34() { return cDividesKeyword_34; }
		
		//'‥'
		public Keyword getTwoDotLeaderKeyword_35() { return cTwoDotLeaderKeyword_35; }
		
		//// Symbols for arithmetic expressions
		//'+'
		public Keyword getPlusSignKeyword_36() { return cPlusSignKeyword_36; }
		
		//'−'
		public Keyword getMinusSignKeyword_37() { return cMinusSignKeyword_37; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_38() { return cHyphenMinusKeyword_38; }
		
		//'∗'
		public Keyword getAsteriskOperatorKeyword_39() { return cAsteriskOperatorKeyword_39; }
		
		//'*'
		public Keyword getAsteriskKeyword_40() { return cAsteriskKeyword_40; }
		
		//'÷'
		public Keyword getDivisionSignKeyword_41() { return cDivisionSignKeyword_41; }
		
		//'/'
		public Keyword getSolidusKeyword_42() { return cSolidusKeyword_42; }
		
		//'^'
		public Keyword getCircumflexAccentKeyword_43() { return cCircumflexAccentKeyword_43; }
		
		//'\\'
		public Keyword getBackslashKeyword_44() { return cBackslashKeyword_44; }
	}
	
	
	private final XProofAssistantElements pXProofAssistant;
	private final XHintElements pXHint;
	private final EStringElements pEString;
	private final XSelectionHintElements pXSelectionHint;
	private final XCasesHintElements pXCasesHint;
	private final XCaseElements pXCase;
	private final TerminalRule tXLABEL;
	private final XFormulaElements pXFormula;
	private final EVENTB_IDENTIFIER_KEYWORDElements pEVENTB_IDENTIFIER_KEYWORD;
	private final EVENTB_PREDICATE_SYMBOLSElements pEVENTB_PREDICATE_SYMBOLS;
	private final EVENTB_EXPRESSION_SYMBOLSElements pEVENTB_EXPRESSION_SYMBOLS;
	private final TerminalRule tID;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public XProofAssistantGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pXProofAssistant = new XProofAssistantElements();
		this.pXHint = new XHintElements();
		this.pEString = new EStringElements();
		this.pXSelectionHint = new XSelectionHintElements();
		this.pXCasesHint = new XCasesHintElements();
		this.pXCase = new XCaseElements();
		this.tXLABEL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xproofassistant.XProofAssistant.XLABEL");
		this.pXFormula = new XFormulaElements();
		this.pEVENTB_IDENTIFIER_KEYWORD = new EVENTB_IDENTIFIER_KEYWORDElements();
		this.pEVENTB_PREDICATE_SYMBOLS = new EVENTB_PREDICATE_SYMBOLSElements();
		this.pEVENTB_EXPRESSION_SYMBOLS = new EVENTB_EXPRESSION_SYMBOLSElements();
		this.tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xproofassistant.XProofAssistant.ID");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("ac.soton.xeventb.xproofassistant.XProofAssistant".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//XProofAssistant ProofAssistant:
	//	'ProofAssistant' name=EString
	//	'supports' component=[core::EventBNamedCommentedComponentElement|EString] ('hints' hints+=XHint+)*
	//	'end';
	public XProofAssistantElements getXProofAssistantAccess() {
		return pXProofAssistant;
	}
	
	public ParserRule getXProofAssistantRule() {
		return getXProofAssistantAccess().getRule();
	}
	
	//XHint Hint:
	//	XSelectionHint | XCasesHint;
	public XHintElements getXHintAccess() {
		return pXHint;
	}
	
	public ParserRule getXHintRule() {
		return getXHintAccess().getRule();
	}
	
	//EString:
	//	STRING | ID;
	public EStringElements getEStringAccess() {
		return pEString;
	}
	
	public ParserRule getEStringRule() {
		return getEStringAccess().getRule();
	}
	
	//XSelectionHint SelectionHint:
	//	'for' element=[core::EventBElement|EString]
	//	'selects' selections+=[core::EventBElement|EString]+;
	public XSelectionHintElements getXSelectionHintAccess() {
		return pXSelectionHint;
	}
	
	public ParserRule getXSelectionHintRule() {
		return getXSelectionHintAccess().getRule();
	}
	
	//XCasesHint CasesHint:
	//	'for' element=[core::EventBElement|EString]
	//	'cases' cases+=XCase+;
	public XCasesHintElements getXCasesHintAccess() {
		return pXCasesHint;
	}
	
	public ParserRule getXCasesHintRule() {
		return getXCasesHintAccess().getRule();
	}
	
	//XCase Case:
	//	name=XLABEL predicate=XFormula;
	public XCaseElements getXCaseAccess() {
		return pXCase;
	}
	
	public ParserRule getXCaseRule() {
		return getXCaseAccess().getRule();
	}
	
	//terminal XLABEL:
	//	'@' !':'+ ':';
	public TerminalRule getXLABELRule() {
		return tXLABEL;
	}
	
	//XFormula:
	//	(EVENTB_IDENTIFIER_KEYWORD | EVENTB_PREDICATE_SYMBOLS | EVENTB_EXPRESSION_SYMBOLS | ID | INT)+;
	public XFormulaElements getXFormulaAccess() {
		return pXFormula;
	}
	
	public ParserRule getXFormulaRule() {
		return getXFormulaAccess().getRule();
	}
	
	//EVENTB_IDENTIFIER_KEYWORD:
	//	'BOOL' |
	//	'FALSE' |
	//	'TRUE' |
	//	'bool' |
	//	'card' |
	//	'dom' |
	//	'finite' |
	//	'id' |
	//	'inter' |
	//	'max' |
	//	'min' |
	//	'mod' |
	//	'pred' |
	//	'prj1' |
	//	'prj2' |
	//	'ran' |
	//	'succ' |
	//	'union' |
	//	'ℕ1' |
	//	'ℕ' |
	//	'ℙ1' |
	//	'ℙ' |
	//	'ℤ';
	public EVENTB_IDENTIFIER_KEYWORDElements getEVENTB_IDENTIFIER_KEYWORDAccess() {
		return pEVENTB_IDENTIFIER_KEYWORD;
	}
	
	public ParserRule getEVENTB_IDENTIFIER_KEYWORDRule() {
		return getEVENTB_IDENTIFIER_KEYWORDAccess().getRule();
	}
	
	//EVENTB_PREDICATE_SYMBOLS:
	//	'(' | // Predicate calculus symbols
	//	')' |
	//	'⇔' |
	//	'⇒' |
	//	'∧' | '&' |
	//	'∨' |
	//	'¬' |
	//	'⊤' |
	//	'⊥' |
	//	'∀' | '!' |
	//	'∃' | '#' |
	//	',' |
	//	'·' | '.' |
	//	'=' | // Build predicates from expressions
	//	'≠' |
	//	'≤' |
	//	'<' |
	//	'≥' |
	//	'>' |
	//	'∈' | ':' | // Include this for Rodin keyboard
	//	'∉' |
	//	'⊂' |
	//	'⊄' |
	//	'⊆' |
	//	'⊈' |
	//	'partition' // This is missing from the Rodin D7 deliverable
	//;
	public EVENTB_PREDICATE_SYMBOLSElements getEVENTB_PREDICATE_SYMBOLSAccess() {
		return pEVENTB_PREDICATE_SYMBOLS;
	}
	
	public ParserRule getEVENTB_PREDICATE_SYMBOLSRule() {
		return getEVENTB_PREDICATE_SYMBOLSAccess().getRule();
	}
	
	//EVENTB_EXPRESSION_SYMBOLS:
	//	'↔' | // Symbols for building set of relations
	//	'' |
	//	'' |
	//	'' |
	//	'⇸' |
	//	'→' |
	//	'⤔' |
	//	'↣' |
	//	'⤀' |
	//	'↠' |
	//	'⤖' |
	//	'{' | // Symbols for manipulating sets
	//	'}' |
	//	'↦' |
	//	'∅' |
	//	'∩' |
	//	'∪' |
	//	'∖' |
	//	'×' |
	//	'[' | // Symbols for manipulating functions and relations
	//	']' |
	//	'' |
	//	'∘' |
	//	';' |
	//	'⊗' |
	//	'∥' |
	//	'∼' |
	//	'◁' |
	//	'⩤' |
	//	'▷' |
	//	'⩥' |
	//	'λ' | '%' // Symbols for quantified expressions
	//	'⋂' |
	//	'⋃' |
	//	'∣' |
	//	'‥' | // Symbols for arithmetic expressions
	//	'+' |
	//	'−' | '-' |
	//	'∗' | '*' |
	//	'÷' | '/' |
	//	'^' |
	//	'\\' // Allowed for LaTeX combos
	//;
	public EVENTB_EXPRESSION_SYMBOLSElements getEVENTB_EXPRESSION_SYMBOLSAccess() {
		return pEVENTB_EXPRESSION_SYMBOLS;
	}
	
	public ParserRule getEVENTB_EXPRESSION_SYMBOLSRule() {
		return getEVENTB_EXPRESSION_SYMBOLSAccess().getRule();
	}
	
	//@Override
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_' | 'i'..'ￜ') ('a'..'z' | 'A'..'Z' | '_' | 'i'..'ￜ' | '0'..'9' | "'")*;
	public TerminalRule getIDRule() {
		return tID;
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
